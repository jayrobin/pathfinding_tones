{"version":3,"sources":["util/tone.ts","model/cell.ts","util/draw.ts","model/grid.ts","util/search/search.ts","util/search/index.ts","util/search/dijkstra.ts","util/search/aStar.ts","util/search/bfs.ts","util/search/dfs.ts","util/search/random.ts","components/canvas.tsx","components/dropdown.tsx","components/ui.tsx","components/app.tsx","index.ts"],"names":["audioCtx","gain","window","AudioContext","createGain","connect","destination","value","CellState","getOscillator","oscillator","createOscillator","type","playTone","frequency","duration","start","setTimeout","stop","playTones","frequencies","length","slice","drawLine","ctx","x1","y1","x2","y2","color","alpha","globalAlpha","strokeStyle","beginPath","moveTo","lineTo","stroke","closePath","Cell","x","y","state","UNEXPLORED","neighbors","metadata","reset","OBSTACLE","addNeighbor","neighbor","push","setUnexplored","setExplored","EXPLORED","setExploring","EXPLORING","isExplored","isObstacle","getNeighbors","filter","getUnexploredNeighbors","distanceTo","cell","Math","abs","euclideanDistanceTo","sqrt","pow","toggleWall","render","size","overrideColor","fillStyle","fillRect","drawSquare","this","Grid","width","height","cellSize","currentTick","cols","search","finished","get","getCellAtScreen","screenX","screenY","floor","setCellStateAtScreen","previousState","setSearch","forEach","row","tick","onClick","getCurrentPath","getShortestPath","getPathFromStartToCell","getUpdatedThisTick","getNumExplored","reduce","sum","rowSum","getUpdatedCells","playTonesForUpdatedCells","tonesForUpdatedCells","getNormalizedFrequenciesForCells","playTonesForCurrentPath","tonesForCurrentPath","reverse","cells","maxDistance","map","getDebugOutput","createGrid","initializeNeighbors","Search","_start","updatedThisTick","path","node","prev","ALGORITHMS","queue","next","pop","distanceFromSourceToNeighbor","distanceFromSource","undefined","data","includes","debugOutput","join","TinyQueue","a","b","openSet","current","tentativeGScore","gScore","fScore","toFixed","shift","stack","splice","random","Canvas","onMouseDown","grid","canvasWidth","canvasHeight","canvasRef","React","useRef","useState","drawType","setDrawType","renderGrid","useCallback","canvas","getContext","drawGrid","drawGridLines","i","offset","drawPathFromGridCoords","useEffect","getCanvasCoordinatesFromScreen","rect","getBoundingClientRect","max","left","top","ref","clientX","clientY","nextDrawType","onMouseUp","onMouseMove","styles","select","padding","Dropdown","options","onChange","style","option","key","container","display","alignItems","flexDirection","canvasContainer","margin","controlsContainer","debugControl","cursor","userSelect","UI","algorithm","playing","onClickPlay","onClickNewGrid","onChangeAlgorithm","onDraw","showDebugOutput","setShowDebugOutput","Object","keys","defaultValue","disabled","alignSelf","App","setPlaying","setAlgorithm","setGrid","setTick","resetGrid","getSearchAlgorithm","timer","nextTick","clearTimeout","e","currentTarget","ReactDOM","createElement","document","getElementById"],"mappings":"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","file":"static/js/main.b4f8c751.chunk.js","sourcesContent":["let audioCtx: AudioContext;\nlet gain: GainNode;\n\nconst getAudioContext = () => {\n  if (!audioCtx) {\n    audioCtx = new(window.AudioContext)();\n\n    gain = audioCtx.createGain();\n    gain.connect(audioCtx.destination);\n    gain.gain.value = -0.99;\n  }\n}\n\ngetAudioContext();\n\nconst getOscillator = () => {\n  const oscillator = audioCtx.createOscillator();\n  oscillator.connect(gain);\n  oscillator.connect(audioCtx.destination);\n  oscillator.type = 'square';\n\n  return oscillator;\n}\n\nexport const playTone = (frequency: number, duration: number = 10) => {\n  const oscillator = getOscillator();\n  if (oscillator) {\n    oscillator.frequency.value = frequency;\n    oscillator.start();\n\n    setTimeout(() => {\n      oscillator.stop();\n    }, duration);\n  }\n}\n\nexport const playTones = (frequencies: number[], duration: number = 20) => {\n  if (!frequencies.length) {\n    return;\n  }\n\n  playTone(frequencies[0], duration);\n  setTimeout(() => {\n    playTones(frequencies.slice(1));\n  }, duration);\n}\n","import { drawSquare } from '../util/draw';\n\nexport enum CellState {\n  OBSTACLE,\n  UNEXPLORED,\n  EXPLORING,\n  EXPLORED\n}\n\nexport default class Cell {\n  x: number;\n  y: number;\n  state: CellState = CellState.UNEXPLORED;\n  neighbors: Cell[];\n  metadata: {\n    [key: string]: any\n  }\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.neighbors = [];\n    this.metadata = {};\n  }\n\n  reset = () => {\n    this.metadata = {};\n    if (this.state !== CellState.OBSTACLE) {\n      this.state = CellState.UNEXPLORED;\n    }\n  }\n\n  addNeighbor = (neighbor: Cell) => {\n    this.neighbors.push(neighbor);\n  }\n\n  setUnexplored = () => {\n    this.state = CellState.UNEXPLORED;\n  }\n\n  setExplored = () => {\n    this.state = CellState.EXPLORED;\n  }\n\n  setExploring = () => {\n    this.state = CellState.EXPLORING;\n  }\n\n  isExplored = () => {\n    return this.state === CellState.EXPLORED;\n  }\n\n  isObstacle = () => {\n    return this.state === CellState.OBSTACLE;\n  }\n\n  getNeighbors = () => {\n    return this.neighbors.filter(({ state }) => state !== CellState.OBSTACLE);\n  }\n\n  getUnexploredNeighbors = () => {\n    return this.neighbors.filter(({ state }) => state === CellState.UNEXPLORED || state === CellState.EXPLORING);\n  }\n\n  distanceTo = (cell: Cell) => {\n    return Math.abs(this.x - cell.x) + Math.abs(this.y - cell.y);\n  }\n\n  euclideanDistanceTo = (cell: Cell) => {\n    return Math.sqrt(Math.pow(this.x - cell.x, 2) + Math.pow(this.y - cell.y, 2));\n  }\n\n  toggleWall = () => {\n    this.state = this.state === CellState.OBSTACLE ? CellState.UNEXPLORED : CellState.OBSTACLE;\n  }\n\n  render = (ctx: CanvasRenderingContext2D, x: number, y: number, size: number, overrideColor?: string) => {\n    let color;\n    switch (this.state) {\n      case CellState.OBSTACLE:\n        color = '#222831';\n        break;\n      case CellState.UNEXPLORED:\n        color = '#eeeeee';\n        break;\n      case CellState.EXPLORING:\n        color = '#d6c4c1';\n        break;\n      case CellState.EXPLORED:\n        color = '#bdbdbd';\n        break;\n      default:\n        color = '#222831';\n    }\n    drawSquare(ctx, x, y, size, overrideColor || color);\n  }\n}\n","import Cell from '../model/cell';\nimport Grid from '../model/grid';\n\nexport const drawSquare = (ctx: CanvasRenderingContext2D, x: number, y: number, size: number, color: string) => {\n  ctx.fillStyle = color;\n  ctx.fillRect(x, y, size, size);\n}\n\nexport const drawLine = (ctx: CanvasRenderingContext2D, x1: number, y1: number, x2: number, y2: number, color = 'black', alpha = 1.0) => {\n  ctx.globalAlpha = alpha;\n  ctx.strokeStyle = color;\n  ctx.beginPath();\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.stroke();\n  ctx.closePath();\n  ctx.globalAlpha = 1.0;\n}\n\nexport const drawPathFromGridCoords = (ctx: CanvasRenderingContext2D, path: Cell[], cellSize: number) => {\n  for (let i = 0; i < path.length - 1; i++) {\n    const { x: x1, y: y1 } = path[i];\n    const { x: x2, y: y2 } = path[i + 1];\n\n    const offset = Math.floor(cellSize / 2);\n    drawLine(ctx, x1 * cellSize + offset, y1 * cellSize + offset, x2 * cellSize + offset, y2 * cellSize + offset);\n  }\n}\n\nexport const drawGrid = (ctx: CanvasRenderingContext2D, grid: Grid) => {\n  for (let y = 0; y < grid.height; y++) {\n    for (let x = 0; x < grid.width; x++) {\n      const cell = grid.get(x, y);\n\n      let overrideColor;\n      if (cell === grid.start) {\n        overrideColor = '#00adb5';\n      } else if (cell === grid.destination) {\n        overrideColor = '#bb596b';\n      }\n\n      cell.render(ctx, x * grid.cellSize, y * grid.cellSize, grid.cellSize, overrideColor);\n    }\n  }\n}\n\n\nexport const drawGridLines = (ctx: CanvasRenderingContext2D, grid: Grid) => {\n  for (let y = 0; y < grid.height; y++) {\n    drawLine(ctx, 0, y * grid.cellSize, grid.width * grid.cellSize, y * grid.cellSize, 'black', 0.3);\n  }\n\n  for (let x = 0; x < grid.height; x++) {\n    drawLine(ctx, x * grid.cellSize, 0, x * grid.cellSize, grid.height * grid.cellSize, 'black', 0.3);\n  }\n}\n\n\nexport const drawCells = (ctx: CanvasRenderingContext2D, cells: Cell[], cellSize: number, start: Cell, destination: Cell) => {\n  cells.forEach((cell) => {\n    let overrideColor;\n    if (cell === start) {\n      overrideColor = '#00adb5';\n    } else if (cell === destination) {\n      overrideColor = '#bb596b';\n    }\n\n    cell.render(ctx, cell.x * cellSize, cell.y * cellSize, cellSize, overrideColor);\n  });\n}\n","import { ISearch } from '../util/search/search';\nimport { playTones } from '../util/tone';\nimport Cell, { CellState } from './cell';\n\nexport default class Grid {\n  currentTick: number;\n  width: number;\n  height: number;\n  cellSize: number;\n  cols: Cell[][];\n  start: Cell;\n  destination: Cell;\n  search?: ISearch;\n  finished: boolean;\n\n  constructor(width: number, height: number, cellSize: number) {\n    this.currentTick = 0;\n    this.width = width;\n    this.height = height;\n    this.cellSize = cellSize;\n    this.cols = Grid.createGrid(width, height);\n\n    this.start = this.get(5, 5);\n    this.start.setUnexplored();\n\n    this.destination = this.get(width - 6, height - 6);\n    this.destination.setUnexplored();\n\n    this.finished = false;\n  }\n\n  get = (x: number, y: number) => {\n    return this.cols[y][x];\n  }\n\n  getCellAtScreen = (screenX: number, screenY: number) => {\n    const x = Math.floor(screenX / this.cellSize);\n    const y = Math.floor(screenY / this.cellSize);\n    return this.get(x, y);\n  }\n\n  setCellStateAtScreen = (screenX: number, screenY: number, state: CellState) => {\n    const x = Math.floor(screenX / this.cellSize);\n    const y = Math.floor(screenY / this.cellSize);\n    const previousState = this.get(x, y).state;\n    this.get(x, y).state = state;\n\n    return previousState !== state;\n  }\n\n  setSearch = (search: ISearch) => {\n    this.search = search;\n  }\n\n  reset = () => {\n    this.cols.forEach((row) => {\n      row.forEach((cell) => {\n        cell.reset();\n      })\n    });\n    this.currentTick = 0;\n    this.finished = false;\n  }\n\n  tick = () => {\n    if (this.search && !this.finished) {\n      this.currentTick++;\n      this.finished = this.search.tick();\n    }\n\n    return this.finished;\n  }\n\n  onClick = (screenX: number, screenY: number) => {\n    this.getCellAtScreen(screenX, screenY).toggleWall();\n  }\n\n  getCurrentPath = () => {\n    if (!this.search) {\n      return [];\n    }\n\n    return this.finished ?\n      this.search.getShortestPath() :\n      this.search.getPathFromStartToCell(this.search.getUpdatedThisTick().slice(-1)[0] as Cell);\n  }\n\n  getNumExplored = () => {\n    return this.cols.reduce((sum, row) => {\n      return sum + row.reduce((rowSum, cell) => {\n        return rowSum + (cell.isExplored() ? 1 : 0)\n      },0)\n    }, 0);\n  }\n\n  getUpdatedCells = () => {\n    if (!this.search) {\n      return [];\n    }\n\n    return this.search.getUpdatedThisTick();\n  }\n\n  playTonesForUpdatedCells = () => {\n    if (!this.search) {\n      return;\n    }\n\n    const tonesForUpdatedCells = this.getNormalizedFrequenciesForCells(this.search.getUpdatedThisTick());\n    playTones(tonesForUpdatedCells);\n  }\n\n  playTonesForCurrentPath = () => {\n    const tonesForCurrentPath = this.getNormalizedFrequenciesForCells(this.getCurrentPath().reverse());\n    playTones(tonesForCurrentPath);\n  }\n\n  getNormalizedFrequenciesForCells = (cells: Cell[]) => {\n    const MAX_FREQUENCY = 2000;\n    const maxDistance = this.start.distanceTo(this.destination);\n    return cells.map((cell) => {\n      return Math.floor(((maxDistance - cell.distanceTo(this.destination)) / maxDistance) * MAX_FREQUENCY);\n    });\n  }\n\n  getDebugOutput = () => {\n    return this.search?.getDebugOutput() || '';\n  }\n\n  static createGrid(width: number, height: number) {\n    const cols = [];\n    for (let y = 0; y < height; y++) {\n      const row = [];\n      for (let x = 0; x < width; x++) {\n        row.push(new Cell(x, y));\n      }\n      cols.push(row);\n    }\n    return Grid.initializeNeighbors(cols);\n  }\n\n  static initializeNeighbors(cols: Cell[][]) {\n    const width = cols.length;\n    const height = cols[0].length;\n    cols.forEach((row, x) => {\n      row.forEach((cell, y) => {\n        if (x > 0) {\n          cell.addNeighbor(cols[x - 1][y]);\n        }\n        if (x < width - 1) {\n          cell.addNeighbor(cols[x + 1][y]);\n        }\n        if (y > 0) {\n          cell.addNeighbor(cols[x][y - 1]);\n        }\n        if (y < height - 1) {\n          cell.addNeighbor(cols[x][y + 1]);\n        }\n\n        // diagonal neighbors\n        // if (x > 0 && y > 0) {\n        //   cell.addNeighbor(cols[x - 1][y - 1]);\n        // }\n        // if (x < width - 1 && y > 0) {\n        //   cell.addNeighbor(cols[x + 1][y - 1]);\n        // }\n        // if (x > 0 && y < height - 1) {\n        //   cell.addNeighbor(cols[x - 1][y + 1]);\n        // }\n        // if (x > width - 1 && y < height - 1) {\n        //   cell.addNeighbor(cols[x + 1][y + 1]);\n        // }\n      })\n    });\n    return cols;\n  }\n}\n","import Cell from '../../model/cell';\n\nexport interface ISearch {\n  tick: () => boolean;\n  getUpdatedThisTick: () => Cell[];\n  getShortestPath: () => Cell[];\n  getPathFromStartToCell: (cell: Cell) => Cell[];\n  getDebugOutput: () => string;\n}\n\nexport default class Search implements ISearch {\n  destination: Cell;\n  updatedThisTick: Cell[];\n\n  constructor(_start: Cell, destination: Cell) {\n    this.destination = destination;\n    this.updatedThisTick = [];\n  }\n\n  tick = () => true\n\n  getUpdatedThisTick = () => {\n    return this.updatedThisTick;\n  }\n\n  getShortestPath = () => {\n    return this.getPathFromStartToCell(this.destination).reverse();\n  }\n\n  getPathFromStartToCell = (cell: Cell) => {\n    const path: Cell[] = [];\n    let node = cell;\n    while (node) {\n      path.push(node);\n      node = node.metadata.prev;\n    }\n\n    return path.reverse();\n  }\n\n  getDebugOutput = () => '';\n}\n","import Dijkstra from './dijkstra';\nimport AStar from './aStar';\nimport BFS from './bfs';\nimport DFS from './dfs';\nimport Random from './random';\n\nexport const ALGORITHMS = {\n  'Dijkstra': Dijkstra,\n  'A*': AStar,\n  'Breadth-first search': BFS,\n  'Depth-first search': DFS,\n  'Random': Random,\n};\n","import TinyQueue from 'tinyqueue';\nimport Cell from '../../model/cell';\nimport Search from './search';\n\nexport default class Dijkstra extends Search {\n  queue: TinyQueue<Cell>;\n\n  constructor(start: Cell, destination: Cell) {\n    super(start, destination);\n\n    start.metadata.distanceFromSource = 0;\n    this.queue = new TinyQueue([start], (a, b) => {\n      return a.metadata.distanceFromSource - b.metadata.distanceFromSource;\n    });\n  }\n\n  tick = () => {\n    if (this.queue.length) {\n      this.updatedThisTick = [];\n      const next = this.queue.pop() as Cell;\n      if (next === this.destination) {\n        return true;\n      }\n\n      const unexploredNeighbors = next.getUnexploredNeighbors();\n      unexploredNeighbors.forEach((neighbor) => {\n        neighbor.setExploring();\n\n        const distanceFromSourceToNeighbor = next.distanceTo(neighbor) + next.metadata.distanceFromSource;\n        if (neighbor.metadata.distanceFromSource === undefined || distanceFromSourceToNeighbor < neighbor.metadata.distanceFromSource) {\n          neighbor.metadata.distanceFromSource = distanceFromSourceToNeighbor;\n          neighbor.metadata.prev = next;\n        }\n        if (!this.queue.data.includes(neighbor)) {\n          this.queue.push(neighbor);\n        }\n        this.updatedThisTick.push(neighbor);\n      });\n      next.setExplored();\n      this.updatedThisTick.push(next);\n\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  getDebugOutput = () => {\n    let debugOutput = 'Queue\\n';\n    debugOutput += this.queue.data.map(({ x, y, metadata }) => `(${x}, ${y}) ${metadata.distanceFromSource}`).join('\\n');\n    return debugOutput;\n  }\n}\n","import TinyQueue from 'tinyqueue';\nimport Cell from '../../model/cell';\nimport Search from './search';\n\nexport default class AStar extends Search {\n  openSet: TinyQueue<Cell>;\n\n  constructor(start: Cell, destination: Cell) {\n    super(start, destination);\n\n    start.metadata.fScore = start.euclideanDistanceTo(destination);\n    start.metadata.gScore = 0;\n    this.openSet = new TinyQueue([start], (a, b) => {\n      return a.metadata.fScore - b.metadata.fScore;\n    });\n  }\n\n  tick = () => {\n    if (this.openSet.length) {\n      this.updatedThisTick = [];\n      const current = this.openSet.pop() as Cell;\n      if (current === this.destination) {\n        return true;\n      }\n\n      const neighbors = current.getNeighbors();\n      neighbors.forEach((neighbor) => {\n        const tentativeGScore = current.metadata.gScore + current.distanceTo(neighbor);\n        if (neighbor.metadata.gScore === undefined || tentativeGScore < neighbor.metadata.gScore) {\n          neighbor.metadata.prev = current;\n          neighbor.metadata.gScore = tentativeGScore;\n          neighbor.metadata.fScore = neighbor.metadata.gScore + neighbor.euclideanDistanceTo(this.destination);\n\n          if (!this.openSet.data.includes(neighbor)) {\n            this.openSet.push(neighbor);\n          }\n          neighbor.setExploring();\n          this.updatedThisTick.push(neighbor);\n        }\n      });\n      current.setExplored();\n      this.updatedThisTick.push(current);\n\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  getDebugOutput = () => {\n    let debugOutput = 'Queue\\n';\n    debugOutput += this.openSet.data.map(({ x, y, metadata }) => `(${x}, ${y}) ${metadata.fScore.toFixed(3)}`).join('\\n');\n    return debugOutput;\n  }\n}\n","import Cell from '../../model/cell';\nimport Search from './search';\n\nexport default class BFS extends Search {\n  queue: Cell[];\n\n  constructor(start: Cell, destination: Cell) {\n    super(start, destination);\n\n    this.queue = [start];\n  }\n\n  tick = () => {\n    if (this.queue.length) {\n      this.updatedThisTick = [];\n      const next = this.queue.shift() as Cell;\n      if (next === this.destination) {\n        return true;\n      }\n\n      const unexploredNeighbors = next.getUnexploredNeighbors();\n      unexploredNeighbors.forEach((neighbor) => {\n        neighbor.setExploring();\n        neighbor.metadata.prev = next;\n        if (!this.queue.includes(neighbor)) {\n          this.queue.push(neighbor);\n        }\n        this.updatedThisTick.push(neighbor);\n      });\n      next.setExplored();\n      this.updatedThisTick.push(next);\n\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  getDebugOutput = () => {\n    let debugOutput = 'Queue\\n';\n    debugOutput += this.queue.map(({ x, y }) => `(${x}, ${y})`).join('\\n');\n    return debugOutput;\n  }\n}\n","import Cell from '../../model/cell';\nimport Search from './search';\n\nexport default class DFS extends Search {\n  stack: Cell[];\n\n  constructor(start: Cell, destination: Cell) {\n    super(start, destination);\n\n    this.stack = [start];\n  }\n\n  tick = () => {\n    if (this.stack.length) {\n      this.updatedThisTick = [];\n      const next = this.stack.pop() as Cell;\n      if (next === this.destination) {\n        return true;\n      }\n\n      const unexploredNeighbors = next.getUnexploredNeighbors();\n      unexploredNeighbors.forEach((neighbor) => {\n        neighbor.setExploring();\n        neighbor.metadata.prev = next;\n        this.stack.push(neighbor);\n        this.updatedThisTick.push(neighbor);\n      });\n      next.setExplored();\n      this.updatedThisTick.push(next);\n\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  getDebugOutput = () => {\n    let debugOutput = 'Stack\\n';\n    debugOutput += this.stack.map(({ x, y }) => `(${x}, ${y})`).join('\\n');\n    return debugOutput;\n  }\n}\n","import Cell from '../../model/cell';\nimport Search from './search';\n\nexport default class Random extends Search {\n  queue: Cell[];\n\n  constructor(start: Cell, destination: Cell) {\n    super(start, destination);\n\n    this.queue = [start];\n  }\n\n  tick = () => {\n    if (this.queue.length) {\n      this.updatedThisTick = [];\n      const next = this.queue.splice(Math.floor(Math.random() * this.queue.length), 1)[0] as Cell;\n      if (next === this.destination) {\n        return true;\n      }\n\n      const unexploredNeighbors = next.getUnexploredNeighbors();\n      unexploredNeighbors.forEach((neighbor) => {\n        neighbor.setExploring();\n        neighbor.metadata.prev = next;\n        this.queue.push(neighbor);\n        this.updatedThisTick.push(neighbor);\n      });\n      next.setExplored();\n      this.updatedThisTick.push(next);\n\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n","import React from 'react';\nimport Grid from '../model/grid';\nimport { CellState } from '../model/cell';\nimport { drawPathFromGridCoords, drawGrid, drawGridLines } from '../util/draw';\n\ntype Props = {\n  grid: Grid;\n  onMouseDown: () => void;\n}\n\nconst Canvas = ({ onMouseDown, grid }: Props) => {\n  const canvasWidth = grid.width * grid.cellSize;\n  const canvasHeight = grid.height * grid.cellSize;\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n\n  const [drawType, setDrawType] = React.useState<CellState | null>(null);\n\n  const renderGrid = React.useCallback(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n      drawGrid(ctx, grid);\n      drawGridLines(ctx, grid);\n      drawPathFromGridCoords(ctx, grid.getCurrentPath(), grid.cellSize)\n    }\n  }, [grid]);\n\n  React.useEffect(() => {\n    renderGrid();\n  }, [grid, grid.currentTick, renderGrid]);\n\n  const getCanvasCoordinatesFromScreen = (screenX: number, screenY: number) => {\n    const canvas = canvasRef.current;\n    let x = 0;\n    let y = 0;\n    if (canvas) {\n      const rect = canvas.getBoundingClientRect();\n      x = Math.max(0, Math.floor(screenX - rect.left));\n      y = Math.max(0, Math.floor(screenY - rect.top));\n    }\n\n    return { x, y };\n  }\n\n  const onCanvasMouseDown = ({ clientX, clientY }: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n    const { x, y } = getCanvasCoordinatesFromScreen(clientX, clientY);\n    const { state } = grid.getCellAtScreen(x, y);\n    const nextDrawType = state === CellState.OBSTACLE ? CellState.UNEXPLORED : CellState.OBSTACLE;\n    setDrawType(nextDrawType);\n    grid.setCellStateAtScreen(x, y, nextDrawType);\n    renderGrid();\n    onMouseDown();\n  }\n\n  const onCanvasMouseUp = () => {\n    setDrawType(null);\n  }\n\n  const onCanvasMouseMove = ({ clientX, clientY }: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n    if (drawType !== null) {\n      const { x, y } = getCanvasCoordinatesFromScreen(clientX, clientY);\n      grid.setCellStateAtScreen(x, y, drawType);\n      renderGrid();\n    }\n  };\n\n  return (\n    <>\n      <canvas\n        ref={canvasRef}\n        width={canvasWidth}\n        height={canvasHeight}\n        onMouseDown={onCanvasMouseDown}\n        onMouseUp={onCanvasMouseUp}\n        onMouseMove={onCanvasMouseMove}\n      />\n    </>\n  )\n}\n\nexport default Canvas;\n","import React from 'react';\n\ntype Props = {\n  value: string;\n  options: string[];\n  onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;\n}\n\nconst Dropdown = ({ value, options, onChange }: Props) => {\n  return (\n    <select value={value} onChange={onChange} style={styles.select}>\n      {options.map((option) => {\n        return <option key={option} value={option}>{option}</option>\n      })}\n    </select>\n  )\n}\n\nconst styles = {\n  select: {\n    width: '100%',\n    padding: '10px',\n  },\n};\n\nexport default Dropdown;\n","import React from 'react';\nimport { ALGORITHMS } from '../util/search';\nimport Grid from '../model/grid';\nimport Canvas from './canvas';\nimport Dropdown from './dropdown';\n\ntype Props = {\n  grid: Grid;\n  algorithm: string;\n  playing: boolean;\n  onClickPlay: () => void;\n  onClickNewGrid: () => void;\n  onChangeAlgorithm: (e: React.ChangeEvent<HTMLSelectElement>) => void;\n  onDraw: () => void;\n}\n\nconst UI = ({\n  grid,\n  algorithm,\n  playing,\n  onClickPlay,\n  onClickNewGrid,\n  onChangeAlgorithm,\n  onDraw,\n  }: Props) => {\n  const [showDebugOutput, setShowDebugOutput] = React.useState(false);\n\n  return (\n    <div style={styles.container}>\n      <div style={styles.canvasContainer}>\n        <Canvas onMouseDown={onDraw} grid={grid} />\n      </div>\n      <div style={styles.controlsContainer}>\n        <Dropdown\n          value={algorithm}\n          options={Object.keys(ALGORITHMS)}\n          onChange={onChangeAlgorithm}\n        />\n        <div>\n          <button onClick={onClickPlay}>{playing ? 'Pause' : 'Play'}</button>\n          <button onClick={onClickNewGrid}>Reset</button>\n        </div>\n      </div>\n      <p onClick={() => setShowDebugOutput(!showDebugOutput)} style={styles.debugControl}>\n        [{showDebugOutput ? '-] Hide' : '+] Show'} debug controls\n      </p>\n      {showDebugOutput && (\n        <>\n          <textarea defaultValue={grid.getDebugOutput()} disabled />\n          <p>Explored: {grid.getNumExplored()}</p>\n          <p>Current path length: {grid.getCurrentPath().length}</p>\n        </>\n      )}\n    </div>\n  )\n}\n\nconst styles = {\n  container: {\n    width: '100%',\n    display: 'flex',\n    alignItems: 'center',\n    flexDirection: 'column' as 'column',\n  },\n  canvasContainer: {\n    margin: '25px',\n  },\n  controlsContainer: {\n    display: 'flex',\n    width: '100%',\n  },\n  debugControl: {\n    cursor: 'pointer',\n    userSelect: 'none' as 'none',\n  }\n};\n\nexport default UI;\n","import React from 'react';\nimport Grid from '../model/grid';\nimport { ALGORITHMS } from '../util/search';\nimport UI from './ui';\n\nconst getSearchAlgorithm = (algorithm: Algorithm, grid: Grid) => new ALGORITHMS[algorithm](grid.start, grid.destination);\n\ntype Algorithm = keyof typeof ALGORITHMS;\n\nconst App = () => {\n  const [playing, setPlaying] = React.useState(false);\n  const [algorithm, setAlgorithm] = React.useState<Algorithm>('A*');\n  const [grid, setGrid] = React.useState(new Grid(30, 30, 15));\n  const [_, setTick] = React.useState(0);\n\n  const onClickNewGrid = () => {\n    setPlaying(false);\n    setTick(0);\n    setGrid(new Grid(30, 30, 15));\n  };\n\n  const resetGrid = React.useCallback(() => {\n    setTick(0);\n    grid.reset();\n    grid.setSearch(getSearchAlgorithm(algorithm, grid));\n  }, [algorithm, grid]);\n\n  const onChangeAlgorithm = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setAlgorithm(e.currentTarget.value as Algorithm);\n  };\n\n  const onClickPlay = () => {\n    if (grid.finished) {\n      resetGrid();\n    }\n    setPlaying(!playing);\n  }\n\n  const onDraw = () => {\n    resetGrid();\n    setPlaying(false);\n  }\n\n  React.useEffect(() => {\n    resetGrid();\n    setPlaying(false);\n  }, [algorithm, grid, resetGrid]);\n\n  React.useEffect(() => {\n    let timer: NodeJS.Timeout;\n    const nextTick = () => {\n      if (playing) {\n        if (grid.tick()) {\n          grid.playTonesForCurrentPath();\n          setPlaying(false);\n        } else {\n          setTick(tick => tick + 1);\n          grid.playTonesForUpdatedCells();\n          timer = setTimeout(nextTick, 25);\n        }\n      }\n    }\n    if (playing) {\n      nextTick();\n    }\n\n    return () => clearTimeout(timer);\n  }, [playing, grid]);\n\n  return (\n    <div style={styles.container}>\n      <h2>The sound of pathfinding</h2>\n      <p><strong>Why I built this:</strong> I wanted to know what different pathfinding algorithms sounded like</p>\n      <div style={styles.canvasContainer}>\n        <UI\n          grid={grid}\n          playing={playing}\n          algorithm={algorithm}\n          onClickNewGrid={onClickNewGrid}\n          onClickPlay={onClickPlay}\n          onChangeAlgorithm={onChangeAlgorithm}\n          onDraw={onDraw}\n        />\n      </div>\n    </div>\n  );\n}\n\nconst styles = {\n  container: {\n    alignItems: 'flex-start',\n    display: 'flex',\n    flexDirection: 'column' as 'column',\n  },\n  canvasContainer: {\n    alignSelf: 'center',\n  }\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/app';\n\nReactDOM.render(React.createElement(App), document.getElementById('root'));\n"],"sourceRoot":""}